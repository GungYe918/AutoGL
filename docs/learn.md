## 0일차 – 그래픽스/렌더링 시스템 완전 기초

**목표**: 그래픽스/렌더링 구조를 완전히 모르는 상태에서,
“프레임, 더블 버퍼링, vsync, 렌더링 파이프라인”의 개념을 말로 설명할 수 있게 만들기.

* 개념

  * CPU vs GPU 역할 분리 (CPU: 명령, GPU: 병렬 픽셀 도장기)
  * **프레임(frame)**, **FPS**, **렌더 루프** 개념
  * **더블 버퍼링(double buffering)**: front/back buffer, 왜 버퍼를 교체하는지
  * **`swapBuffers`**가 하는 일, swap 끄면 Linux에서 왜 화면이 안 나오는지
  * **수직 동기화(vsync)**: 화면 찢어짐(tearing) 방지, 프레임 락
  * OpenGL은 “라이브러리”라기보다는 **사양(spec)** 이고, 실제 구현은 GPU 드라이버가 한다는 점
  * 초초간단 렌더링 파이프라인 개념:

    * 정점 데이터 -> 정점 셰이더 -> 래스터라이저 -> 프래그먼트 셰이더 -> 프레임버퍼

* 과제

  * 글로만: “CPU와 GPU가 한 프레임을 만드는 과정”을 A4 반 페이지 설명해 보기
  * “swapBuffers가 왜 필요한지”를 자기가 이해한 대로 정리

---

## 1일차 – 개발 환경 & GLFW/GLAD 세팅 다시 확인

**목표**: [Opengl 자동 실행기](https://github.com/GungYe918/AutoGL)의 구조를 완전히 이해

* 개념

  * OpenGL은 OS에서 **직접 창을 만들지 않는다 -> GLFW가 해주는 일 정리**
  * GLAD의 역할: 플랫폼별로 OpenGL 함수 포인터 로딩
  * 컨텍스트(context)의 의미: “이 창에서 사용할 OpenGL 상태/리소스 묶음”
* 실습

  * 빈 창 띄우기+배경색 바꾸기 (glClearColor + glClear)
  * `run.sh src/main.cpp` 한 번 더 실행해 보고, 로그 읽어보기

---

## 2일차 – 렌더 루프와 이벤트 처리

**목표**: “게임 루프” 구조를 정확히 이해하고, `swapBuffers`, `glfwPollEvents`의 역할을 명확히 구분.

* 개념

  * while 루프의 구조: 입력 처리 -> 업데이트 -> 렌더링 -> 버퍼 스왑
  * 입력이 프레임 단위로 처리되는 이유
  * vsync 켜고 끄기 (`glfwSwapInterval(1/0)`)와 FPS 변화 관찰
* 실습

  * 키보드 입력으로 ESC 누르면 창 닫기
  * vsync ON/OFF를 번갈아 켜 보고 CPU 점유율, FPS 비교

---

## 3일차 – Hello Triangle 개념편: 정점과 셰이더

**목표**: “GPU는 정점 배열을 받아서 셰이더를 통해 색을 계산한다”는 흐름 이해.

* 개념

  * LearnOpenGL의 **Hello Triangle** 흐름 요약
  * **정점(vertex)**, **프래그먼트(fragment)** 개념
  * 정점 셰이더 / 프래그먼트 셰이더 역할
  * GLSL 기초 문법: `in`, `out`, `uniform` 정도
* 실습

  * CPU에서 삼각형 3개 좌표를 하드코딩 -> GPU로 보내기 전 “종이 위에 좌표 찍어보기”
  * 셰이더는 일단 문자열 그대로 main에 박아두고, 컴파일/링크 실패 시 에러 로그 출력

---

## 4일차 – Hello Triangle 실습편: 처음으로 삼각형 띄우기

**목표**: 진짜 화면에 삼각형 하나 띄우기.

* 개념

  * `glGenBuffers`, `glBindBuffer`, `glBufferData`(“GPU 메모리에 복붙하기” 느낌)
  * **VBO(정점 버퍼)** 개념을 맛보기 수준으로 도입 (이론은 15일차에 다시 정리)
  * `glVertexAttribPointer`, `glEnableVertexAttribArray`
  * `glDrawArrays(GL_TRIANGLES, ...)`
* 실습

  * 화면 가운데 흰 삼각형 하나 렌더링
  * 정점 위치를 직접 바꿔보며, 화면에서 위치가 어떻게 바뀌는지 확인

---

## 5일차 – 좌표계와 NDC, viewport

**목표**: “왜 좌표 (0,0)~(800,600)이 아니라 -1~1로 그리냐?” 감 잡기.

* 개념

  * **NDC(Normalized Device Coordinates)**: -1 ~ 1 공간
  * 클립 공간 -> NDC -> viewport 변환(아직 행렬 공식은 생략)
  * `glViewport`의 역할
* 실습

  * 서로 다른 좌표 세트로 삼각형 여러 개 그려보고, “NDC의 감각” 익히기
  * 창 크기 바꾸면 배율이 어떻게 깨지는지 관찰

---

## 6일차 – EBO/Index Buffer & 사각형 그리기

**목표**: 인덱스 버퍼(EBO) 개념과, 삼각형 2개로 사각형 만들기.

* 개념

  * 중복 정점 vs 인덱스 사용하는 효율성
  * `GL_ELEMENT_ARRAY_BUFFER`, `glDrawElements`
* 실습

  * 4개의 정점 + 인덱스 6개로 사각형 렌더링
  * 인덱스를 일부러 잘못 적어보고, 어떻게 깨지는지 실험

---

## 7일차 – 색상과 인터폴레이션, varying

**목표**: 정점에 색상 넣어서 그라디언트 삼각형을 이해.

* 개념

  * 정점 속성(attribute)을 여러 개 주는 방식: position + color
  * 정점 셰이더에서 색을 프래그먼트 셰이더로 넘길 때 인터폴레이션되는 개념
* 실습

  * RGB 색상이 꼭짓점마다 다른 삼각형 -> 가운데는 색 섞여 보이는 것 시각적으로 확인

---

## 8일차 – 셰이더 구조 정리 & C++ 래핑

**목표**: 셰이더 컴파일/링크 코드를 잘게 쪼개서 `Shader` 클래스로 묶기.

* 개념

  * 셰이더 프로그램의 라이프사이클: `glCreateShader -> glCompileShader -> glAttachShader -> glLinkProgram -> glUseProgram`
  * 에러 핸들링 전략
* 실습

  * `Shader` C++ 클래스를 만들어서:

    * 파일에서 GLSL 읽기
    * 컴파일/링크
    * `use()`, `setUniform()` 같은 헬퍼 함수 구현

---

## 9일차 – 텍스처 2D 기초

**목표**: 이미지 하나를 quad에 붙여서 화면에 표시.

* 개념

  * 텍스처 좌표 (0~1), 반복, 필터링
  * `glGenTextures`, `glBindTexture`, `glTexImage2D`, `glTexParameteri`
* 실습

  * stb_image 등으로 PNG/JPG 로드 -> 텍스처로 적용
  * 이미지 뒤집힘(y-flip) 옵션 토글해보기

---

## 10일차 – 키보드/마우스 입력과 간단한 애니메이션

**목표**: 시간과 입력을 이용해서 간단히 색/위치 애니메이션.

* 개념

  * `glfwGetTime` 이용한 deltaTime
  * `glfwGetKey`, `glfwSetKeyCallback` 차이
* 실습

  * 시간이 흐르면서 배경색이 부드럽게 변하는 프로그램
  * 방향키로 2D 삼각형 위치 이동

---

## 11일차 – 선형대수 기초: 벡터, 내적, 외적

**목표**: “왜 행렬이 필요한지”를 선형대수 기초에서부터 이해.

* 개념(수식보단 개념 위주)

  * 2D/3D 벡터, 길이, 정규화
  * 내적: 투영, 각도와의 관계
  * 외적: 두 벡터에 수직인 벡터
  * “좌표축”이라는 것이 결국 벡터라는 관점
* 실습

  * C 또는 C++로 간단한 `Vec3` 구조체 구현, 길이/정규화 함수 직접 작성
  * 두 벡터의 내적/외적 결과를 콘솔에 찍어보고, 방향/각도 추론해보기

---

## 12일차 – 2D 변환 행렬: 이동/회전/스케일

**목표**: 2D에서라도 행렬이 하는 일을 눈으로 이해.

* 개념

  * 3x3(또는 4x4) 행렬로 2D 변환 표현하기
  * `T * R * S` 순서에 따라 결과가 달라지는 이유
* 실습

  * GLM 라이브러리 또는 직접 만든 행렬 구조체를 이용해서:

    * 삼각형을 회전시키고, 스케일링하고, 이동
  * 셰이더에 `mat4` uniform 넘겨서 실제로 돌려보기

---

## 13일차 – MVP의 싹: 모델 변환과 화면 변환 맛보기

**목표**: “모델 행렬”이 뭔지, 나중에 뷰/투영과 어떻게 이어질지 감 잡기.

* 개념

  * 모델 좌표 -> 월드 좌표 개념
  * 여러 개의 삼각형에 서로 다른 모델 행렬을 적용해 보는 상상
* 실습

  * 두 개의 삼각형을 서로 다른 위치/각도로 배치
  * 코드에서 `model` 행렬 두 개 만들어서 각각 다른 uniform으로 셰이더에 전달

---

## 14일차 – 3D로 넘어가기 전: 2D vs 3D 투영 개념

**목표**: 정사영(orthographic), 원근투영(perspective) 감 잡기.

* 개념

  * 사람 눈/카메라의 원근감: 가까운 것은 크게, 먼 것은 작게
  * 직교 투영 vs 원근 투영 차이
  * FOV, aspect ratio, near/far plane 개념
* 실습

  * ortho-like 변환 vs perspective-like 변환을 2D에서 흉내내 보는 간단한 예제
  * 텍스트/그림으로 FOV 변화 그려보기

---

## 15일차 – **핵심 정리 데이: VBO/VAO & OpenGL에서의 행렬 총합 정리**

**목표**:

* VBO/VAO가 하는 일을 **메모리/상태 관점에서 정확히 이해**

* OpenGL에서 **행렬이 실제로 어떻게 쓰이는지(MVP 구조)** 이론+코드를 한 번에 정리.

* 개념

  * **VBO**: 정점 데이터가 들어 있는 GPU 메모리 상의 “긴 배열”
  * **VAO**: “이 VBO들을 어떻게 해석할지”에 대한 설정(상태) 묶음

    * VAO에 저장되는 것: enabled attribute slot, stride, offset, 바인딩된 VBO
  * **OpenGL에서의 행렬**:

    * Model: 개별 오브젝트의 위치/회전/스케일
    * View: 카메라(눈) 위치/방향
    * Projection: 화면(렌즈) 설정
    * 전체 변환: `clipPos = projection * view * model * vec4(position, 1.0);`

* 코드 설명

  * `glGenVertexArrays`, `glBindVertexArray`, `glVertexAttribPointer` 호출 순서 정리
  * “VAO 없이 VBO만 쓰면 매 프레임 설정 지옥이 온다”는 이야기를 실제 코드 예와 비교

* 실습

  * 깔끔한 VBO/VAO + MVP 셋업 코드 한 번 작성해 보고:

    * 삼각형 하나를 `model` 행렬로 움직이고
    * `view`, `projection`은 임시로 단위행렬 혹은 간단한 설정 사용
  * 주석으로 “지금 이 행렬이 하는 일”을 한 줄씩 달아보기

---

## 16일차 – 3D 좌표계 & 깊이 버퍼(depth buffer)

**목표**: 3D에서 z축이 왜 필요한지, depth 테스트 개념 이해.

* 개념

  * 로컬 -> 월드 -> 뷰 -> 클립 -> NDC -> 화면 좌표 전체 흐름
  * `glEnable(GL_DEPTH_TEST)`, 깊이 버퍼가 없으면 어떤 문제가 생기는지(z-fighting 등 개념 맛보기)
* 실습

  * 사각형 2개를 z값만 다르게 배치하고, depth test 켜고 끄며 확인

---

## 17일차 – 카메라 개념 & lookAt 행렬

**목표**: “카메라가 움직인다”는 것이 결국 “세계가 반대로 움직인다”는 사실 이해.

* 개념

  * 카메라 위치/방향/업 벡터
  * `lookAt(eye, center, up)`의 개념적인 의미 (자세한 수학은 옵션)
* 실습

  * GLM의 `glm::lookAt` 사용해서 간단한 뷰 행렬 생성
  * 카메라 z축 이동 (앞/뒤로 움직이기) 구현

---

## 18일차 – 첫 3D 삼각형: 원근 투영 + 카메라 + 회전

**목표**: 진짜 “3D 삼각형 하나”를 그려 보고, 회전시키기.

* 개념

  * `glm::perspective(fov, aspect, near, far)` 사용
  * `model`에 회전 행렬 넣고, `view`, `projection`과 곱해서 최종 위치 결정
* 실습

  * z가 -2 정도에 있는 한 개의 3D 삼각형을 그리기
  * `glm::rotate` 이용해서 삼각형을 계속 회전시키기

---

## 19일차 – 3D 큐브와 여러 개 오브젝트

**목표**: 3D 공간에 큐브(육면체)를 두고 회전시키며, 여러 개 배치.

* 개념

  * 큐브 정점 데이터(36개 또는 24+index)
  * 여러 `model` 행렬을 사용해 서로 다른 위치/회전의 큐브 배치
* 실습

  * 3개 이상의 큐브를 약간씩 다른 위치에 두고 모두 동시에 회전시키기

---

## 20일차 – 조명 이론 기초: 램버트(Lambert)와 법선

**목표**: “왜 법선(normal)이 필요하고, 빛 세기 = cos(각도)인지” 감 잡기.

* 개념

  * 표면 법선 벡터의 의미
  * Lambertian diffuse: `max(dot(N, L), 0)` 정도의 직관
  * 환경광(ambient), 난반사(diffuse) 개념
* 실습

  * CPU에서 법선 벡터 1~2개를 직접 계산해보고, 내적값 변화 시각화(콘솔/간단 그래프)

---

## 21일차 – 조명 구현: 기본 directional light

**목표**: 조명 하나로 빛 받는 큐브 그려보기.

* 개념

  * 정점 속성에 법선 추가
  * 조명 계산을 프래그먼트 셰이더에서 수행
* 실습

  * directional light 하나를 씬에 두고, 조명의 방향을 바꿔가며 큐브 표면 색 변화 관찰

---

## 22일차 – specular, material 개념

**목표**: 하이라이트가 왜 생기고, shininess가 무슨 역할인지 이해.

* 개념

  * Blinn-Phong 또는 Phong specular 개념
  * material의 ambient/diffuse/specular + shininess
* 실습

  * 하나의 큐브에 specular 하이라이트 추가
  * shininess 값을 크게/작게 바꿔보며 시각적 차이 확인

---

## 23일차 – 여러 개의 조명과 조금 더 복잡한 씬

**목표**: 여러 광원과 여러 오브젝트를 머릿속에서 그릴 수 있는 수준.

* 개념

  * point light vs directional light 직관
  * 여러 개의 조명을 배열로 셰이더에 전달하는 구조
* 실습

  * 2~3개의 점광원을 둔 작은 씬 구성

---

## 24일차 – 계층적 변환(부모-자식 트랜스폼) 직관

**목표**: “부모가 회전하면 자식도 같이 돌지만, 자식은 자신의 축 기준으로 또 돌 수 있다” 이해.

* 개념

  * 모델 행렬을 두 번 곱하는 개념: `model_parent * model_child`
  * 로봇 팔, 태양-지구-달 시스템 같은 예
* 실습

  * 작은 큐브를 큰 큐브 주변을 도는 “위성”처럼 구현(부모-자식 변환)

---

## 25일차 – 코드 구조 리팩터링: Renderer/Shader/Camera 클래스

**목표**: 스파게티 main.cpp를 정리해서 “재사용 가능한 코드 구조”를 만든다.

* 개념

  * 책임 분리: Shader, Camera, Mesh, Renderer 구조
  * main에서는 “장면 구성” 위주로만 코드를 남기는 방향
* 실습

  * 현재까지 쌓인 코드를 간단한 클래스로 나누어 재구성

---

## 26일차 – 디버깅/도구: 와이어프레임, 좌표축 그리기

**목표**: 3D 디버깅용 도구 만들기.

* 개념

  * `glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)`로 wireframe 모드
  * 단순한 XYZ 축 모델 만들어서 씬에 항상 그리기
* 실습

  * 카메라가 어디를 보고 있는지 대략 감 잡을 수 있도록 축/그리드 표시

---

## 27일차 – 3D 삼각형 프로젝트 1: 다양한 삼각형 조합

**목표**: 3D 공간에 여러 개의 삼각형(각자 다른 변환)을 배치할 수 있게 하기.

* 개념

  * 삼각형 데이터를 구조체/배열로 관리하고, 각 삼각형당 모델 행렬 유지
* 실습

  * 서로 다른 위치/각도/색을 가진 3D 삼각형들을 5개 이상 배치
  * 키보드로 카메라 이동하면서 관찰

---

## 28일차 – 수학/좌표계 복습 & 이론 정리

**목표**: 지금까지 배운 모든 좌표계/행렬 개념을 말로 정리할 수 있는 상태 만들기.

* 개념 정리 문서 작성:

  * 로컬 / 월드 / 뷰 / 클립 / NDC / 화면 좌표
  * Model / View / Projection 행렬의 역할과 조합 순서
  * VBO/VAO/EBO가 각각 하는 일 요약
* 실습

  * 스스로 A4 1~2장 분량으로 “내가 이해한 OpenGL 렌더링 파이프라인” 글 작성

---

## 29일차 – 처음부터 다시: 빈 프로젝트에서 3D 삼각형까지 구현

**목표**: 아무 것도 없는 상태에서 **기억만으로** 3D 삼각형을 띄울 수 있는지 확인.

* 실습

  * 새로운 main.cpp를 만들고, 다음 순서를 기억만 보고 구성:

    * GLFW/GLAD 초기화
    * VBO/VAO 만들기
    * 셰이더 작성
    * MVP 행렬 만들어 넘기기
    * 3D 삼각형 하나 렌더
  * 막히는 포인트 체크 -> 30일차에 보완

---

## 30일차 – 최종 정리: 3D 삼각형 + 3D 행렬 완전 이해 상태

**목표**:

* 3D 삼각형을 자유롭게 배치할 수 있고

* “OpenGL에서 행렬과 버퍼가 어떻게 연결되는지”를 **말+코드**로 설명 가능 상태.

* 요구 수준

  * 직접:

    * 3D 삼각형 몇 개를 다른 위치에 배치
    * 카메라를 회전/이동
    * `model/view/projection` 행렬을 코드로 만들고, 각 요소가 무엇을 의미하는지 주석으로 설명
  * 이론적으로:

    * “왜 `projection * view * model * vec4(pos, 1.0)` 순서인지” 설명
    * “VBO/VAO가 없으면 매 프레임 무슨 일이 일어나는지” 이야기 가능
    * “swapBuffers와 vsync가 실제 렌더링 결과에 어떤 영향을 주는지” 다시 설명 가능

* 마지막 과제

  * 지금까지 만든 3D 씬(삼각형 or 큐브)을 스크린샷 찍고,
  * 코드와 함께 “내가 30일 동안 배운 OpenGL 렌더링 파이프라인”을 요약해두기

---
